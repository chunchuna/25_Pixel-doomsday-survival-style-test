{
	"name": "Intro",
	"layers": [
		{
			"name": "Intro",
			"overriden": 0,
			"subLayers": [],
			"instances": [
				{
					"type": "IntroHTML",
					"properties": {
						"tag": "div",
						"content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Chunchun Studio - Simple Animation</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            overflow: hidden;\n        }\n        body {\n            background-color: #fff;\n            font-family: Arial, sans-serif;\n        }\n        #container {\n            position: absolute;\n            width: 100%;\n            height: 100%;\n        }\n        #loading {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            color: #333;\n            font-size: 16px;\n            text-align: center;\n        }\n        .hidden {\n            display: none;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"container\"></div>\n    <div id=\"loading\">Loading...</div>\n\n    <!-- Import Three.js and addons as ES modules -->\n    <script type=\"importmap\">\n    {\n        \"imports\": {\n            \"three\": \"https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js\",\n            \"three/addons/\": \"https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/\"\n        }\n    }\n    </script>\n    <script type=\"module\">\n        import * as THREE from 'three';\n        import { FontLoader } from 'three/addons/loaders/FontLoader.js';\n        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';\n        import { gsap } from 'https://cdn.jsdelivr.net/npm/gsap@3.12.2/+esm';\n\n        // CONFIGURATION - Game window settings\n        const CONFIG = {\n            // Set your game's aspect ratio here (width/height)\n            gameAspectRatio: 4/3, // 4:3 aspect ratio\n            \n            // Default dimensions (used for initial setup and calculations)\n            gameWidth: 640,  // Width in pixels\n            gameHeight: 480, // Height in pixels\n            \n            // Use fixed dimensions instead of aspect ratio\n            useFixedDimensions: false,\n            \n            // Text scale factor (adjust if text appears too large/small)\n            textScaleFactor: 1.0,\n            \n            // Maintain aspect ratio when resizing\n            maintainAspectRatio: true\n        };\n\n        // Scene setup\n        const container = document.getElementById('container');\n        const scene = new THREE.Scene();\n        scene.background = new THREE.Color(0xffffff); // White background\n        \n        // Global variables for text management\n        let textGroup; // Group to hold all letter meshes\n        let textWidth = 0; // Total width of text\n        let textHeight = 0; // Total height of text\n        \n        // Camera setup with game aspect ratio\n        const camera = new THREE.PerspectiveCamera(\n            45, \n            CONFIG.useFixedDimensions ? CONFIG.gameWidth / CONFIG.gameHeight : CONFIG.gameAspectRatio, \n            0.1, \n            1000\n        );\n        camera.position.set(0, 0, 50);\n        camera.lookAt(0, 0, 0);\n        \n        // Renderer setup\n        const renderer = new THREE.WebGLRenderer({ antialias: true });\n\n        // Set renderer size based on configuration\n        function updateRendererSize() {\n            if (CONFIG.useFixedDimensions) {\n                // Use fixed dimensions\n                renderer.setSize(CONFIG.gameWidth, CONFIG.gameHeight);\n                container.style.width = CONFIG.gameWidth + 'px';\n                container.style.height = CONFIG.gameHeight + 'px';\n                \n                // Center the renderer in the window\n                container.style.position = 'absolute';\n                container.style.left = '50%';\n                container.style.top = '50%';\n                container.style.transform = 'translate(-50%, -50%)';\n            } else if (CONFIG.maintainAspectRatio) {\n                // Maintain aspect ratio while filling available space\n                const windowWidth = window.innerWidth;\n                const windowHeight = window.innerHeight;\n                \n                let width, height;\n                \n                // Calculate dimensions that maintain aspect ratio\n                const windowRatio = windowWidth / windowHeight;\n                const gameRatio = CONFIG.gameAspectRatio;\n                \n                if (windowRatio > gameRatio) {\n                    // Window is wider than game ratio\n                    height = windowHeight;\n                    width = height * gameRatio;\n                } else {\n                    // Window is taller than game ratio\n                    width = windowWidth;\n                    height = width / gameRatio;\n                }\n                \n                // Apply calculated dimensions\n                renderer.setSize(width, height);\n                container.style.width = width + 'px';\n                container.style.height = height + 'px';\n                \n                // Center the renderer in the window\n                container.style.position = 'absolute';\n                container.style.left = '50%';\n                container.style.top = '50%';\n                container.style.transform = 'translate(-50%, -50%)';\n                \n                // Update camera aspect ratio\n                camera.aspect = gameRatio;\n                camera.updateProjectionMatrix();\n            } else {\n                // Fill entire window without maintaining aspect ratio\n                renderer.setSize(window.innerWidth, window.innerHeight);\n            }\n        }\n\n        // Initial size setup\n        updateRendererSize();\n\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.shadowMap.enabled = true;\n        renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n        container.appendChild(renderer.domElement);\n        \n        // Lighting for interior scene\n        function setupLighting() {\n            // Ambient light\n            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);\n            scene.add(ambientLight);\n            \n            // Directional light (like sunlight through windows)\n            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n            directionalLight.position.set(10, 20, 15);\n            directionalLight.castShadow = true;\n            directionalLight.shadow.camera.near = 0.1;\n            directionalLight.shadow.camera.far = 100;\n            directionalLight.shadow.camera.left = -20;\n            directionalLight.shadow.camera.right = 20;\n            directionalLight.shadow.camera.top = 20;\n            directionalLight.shadow.camera.bottom = -20;\n            directionalLight.shadow.mapSize.width = 2048;\n            directionalLight.shadow.mapSize.height = 2048;\n            scene.add(directionalLight);\n            \n            // Point light\n            const pointLight = new THREE.PointLight(0xffffff, 0.5);\n            pointLight.position.set(-10, 5, 10);\n            scene.add(pointLight);\n        }\n        \n        // Create interior environment\n        function createInterior() {\n            // Floor\n            const floorGeometry = new THREE.PlaneGeometry(200, 200);\n            const floorMaterial = new THREE.MeshStandardMaterial({\n                color: 0xf5f5f5,\n                roughness: 0.1,\n                metalness: 0.1\n            });\n            const floor = new THREE.Mesh(floorGeometry, floorMaterial);\n            floor.rotation.x = -Math.PI / 2;\n            floor.position.y = -10;\n            floor.receiveShadow = true;\n            scene.add(floor);\n            \n            // No grid, as requested\n            \n            // Subtle fog for depth\n            scene.fog = new THREE.Fog(0xffffff, 70, 200);\n        }\n        \n        // Create letters for \"Chunchun Studio\"\n        function createLetters(font) {\n            const letters = [];\n            const text = \"Chunchun Studio\";\n            \n            // Create a group to hold all letters\n            textGroup = new THREE.Group();\n            scene.add(textGroup);\n            \n            // Apply scale factor to text\n            const baseSize = 3 * CONFIG.textScaleFactor;\n            const largeSize = 4 * CONFIG.textScaleFactor;\n            \n            // Common material for all letters\n            const material = new THREE.MeshPhysicalMaterial({\n                color: 0x2b5797,\n                metalness: 0.7,\n                roughness: 0.2,\n                reflectivity: 0.8,\n                clearcoat: 0.5,\n                clearcoatRoughness: 0.3\n            });\n            \n            // Create individual letters\n            for (let i = 0; i < text.length; i++) {\n                if (text[i] === ' ') continue; // Skip spaces\n                \n                const letterGeometry = new TextGeometry(text[i], {\n                    font: font,\n                    size: text[i] === 'S' ? largeSize : baseSize, // Make first letter of Studio larger\n                    height: 1 * CONFIG.textScaleFactor,\n                    curveSegments: 12,\n                    bevelEnabled: true,\n                    bevelThickness: 0.2 * CONFIG.textScaleFactor,\n                    bevelSize: 0.1 * CONFIG.textScaleFactor,\n                    bevelOffset: 0,\n                    bevelSegments: 5\n                });\n                \n                letterGeometry.computeBoundingBox();\n                \n                const letter = new THREE.Mesh(letterGeometry, material);\n                letter.castShadow = true;\n                letter.receiveShadow = true;\n                \n                // Set initial random position far away\n                const distance = 100 + Math.random() * 50;\n                const theta = Math.random() * Math.PI * 2;\n                const phi = Math.random() * Math.PI;\n                \n                letter.position.x = distance * Math.sin(phi) * Math.cos(theta);\n                letter.position.y = distance * Math.sin(phi) * Math.sin(theta);\n                letter.position.z = distance * Math.cos(phi);\n                \n                // Random rotation\n                letter.rotation.x = Math.random() * Math.PI;\n                letter.rotation.y = Math.random() * Math.PI;\n                letter.rotation.z = Math.random() * Math.PI;\n                \n                // Store original character and index for positioning\n                letter.userData = {\n                    char: text[i],\n                    index: i,\n                    isSpace: false\n                };\n                \n                textGroup.add(letter);\n                letters.push(letter);\n            }\n            \n            return letters;\n        }\n        \n        // Calculate final positions for letters\n        function calculateFinalPositions(letters) {\n            // First, measure total width of text\n            let totalWidth = 0;\n            let maxHeight = 0;\n            let letterWidths = [];\n            \n            letters.forEach(letter => {\n                const width = letter.geometry.boundingBox.max.x - letter.geometry.boundingBox.min.x;\n                const height = letter.geometry.boundingBox.max.y - letter.geometry.boundingBox.min.y;\n                letterWidths.push(width);\n                totalWidth += width;\n                maxHeight = Math.max(maxHeight, height);\n            });\n            \n            // Add spacing between letters\n            const letterSpacing = 2.2 * CONFIG.textScaleFactor;\n            totalWidth += (letters.length - 1) * letterSpacing;\n            \n            // Add extra space for the space between \"Chunchun\" and \"Studio\"\n            const wordSpacing = 6 * CONFIG.textScaleFactor;\n            totalWidth += wordSpacing;\n            \n            // Store text dimensions for responsive adjustments\n            textWidth = totalWidth;\n            textHeight = maxHeight;\n            \n            // Calculate starting X position to center the entire text\n            let currentX = -totalWidth / 2;\n            \n            // Position each letter\n            let letterIndex = 0;\n            for (let i = 0; i < letters.length; i++) {\n                const letter = letters[i];\n                const width = letterWidths[i];\n                \n                // Set target position\n                letter.userData.targetPosition = {\n                    x: currentX + width / 2,\n                    y: 0,\n                    z: 0\n                };\n                \n                letter.userData.targetRotation = {\n                    x: 0,\n                    y: 0,\n                    z: 0\n                };\n                \n                // Update current X position\n                currentX += width + letterSpacing;\n                \n                // Add extra space after \"Chunchun\"\n                if (letter.userData.char === 'n' && letter.userData.index === 7) {\n                    currentX += wordSpacing;\n                }\n                \n                letterIndex++;\n            }\n        }\n        \n        // Animate letters flying in\n        function animateLetters(letters) {\n            letters.forEach((letter, index) => {\n                const delay = index * 0.15; // Stagger the animations\n                const duration = 2.0 + Math.random() * 0.5; // Slightly random durations\n                \n                // Position animation\n                gsap.to(letter.position, {\n                    x: letter.userData.targetPosition.x,\n                    y: letter.userData.targetPosition.y,\n                    z: letter.userData.targetPosition.z,\n                    duration: duration,\n                    delay: delay,\n                    ease: \"power2.out\",\n                    onComplete: () => {\n                        // Store original position for reference as soon as letter arrives\n                        letter.userData.originalPosition = {\n                            x: letter.position.x,\n                            y: letter.position.y,\n                            z: letter.position.z\n                        };\n                        \n                        // Start floating immediately when letter arrives at position\n                        startFloatingAnimation(letter);\n                    }\n                });\n                \n                // Rotation animation\n                gsap.to(letter.rotation, {\n                    x: letter.userData.targetRotation.x,\n                    y: letter.userData.targetRotation.y,\n                    z: letter.userData.targetRotation.z,\n                    duration: duration * 0.8,\n                    delay: delay + duration * 0.2, // Start rotating a bit after movement begins\n                    ease: \"power1.out\"\n                });\n            });\n            \n            // After all letters have arrived, emit completion event\n            const maxDelay = letters.length * 0.15;\n            const maxDuration = 2.5;\n            const totalTime = maxDelay + maxDuration + 0.5; // Add a little buffer\n            \n            setTimeout(() => {\n                // Emit completion event directly (no bounce effect)\n                const event = new Event('animationCompleted');\n                document.dispatchEvent(event);\n            }, totalTime * 1000);\n        }\n        \n        // Add continuous floating animation\n        function startFloatingAnimation(letter) {\n            // Generate random values for this letter's animation\n            const floatAmplitude = (0.15 + Math.random() * 0.1) * CONFIG.textScaleFactor;\n            const floatSpeed = 1.0 + Math.random() * 0.5;\n            const rotateAmplitude = 0.03 + Math.random() * 0.02;\n            \n            // Vertical floating animation\n            gsap.to(letter.position, {\n                y: letter.userData.originalPosition.y + floatAmplitude,\n                duration: floatSpeed,\n                ease: \"sine.inOut\",\n                yoyo: true,\n                repeat: -1 // Infinite repeat\n            });\n            \n            // Very subtle rotation animation\n            gsap.to(letter.rotation, {\n                x: letter.userData.targetRotation.x + rotateAmplitude,\n                y: letter.userData.targetRotation.y + rotateAmplitude,\n                duration: floatSpeed * 1.2,\n                ease: \"sine.inOut\",\n                yoyo: true,\n                repeat: -1 // Infinite repeat\n            });\n            \n            // Extremely subtle horizontal movement\n            if (Math.random() > 0.5) {\n                gsap.to(letter.position, {\n                    x: letter.userData.originalPosition.x + floatAmplitude * 0.3,\n                    duration: floatSpeed * 1.5,\n                    ease: \"sine.inOut\",\n                    yoyo: true,\n                    repeat: -1 // Infinite repeat\n                });\n            }\n        }\n        \n        // Camera movement\n        function setupCameraAnimation() {\n            // Initial position looking at the scene from a distance\n            camera.position.set(0, 10, 80);\n            camera.lookAt(0, 0, 0);\n            \n            // Animate camera to final position\n            gsap.to(camera.position, {\n                x: 0,\n                y: 5,\n                z: calculateIdealCameraDistance(),\n                duration: 4,\n                ease: \"power2.inOut\"\n            });\n        }\n        \n        // Calculate ideal camera distance based on text size and game aspect ratio\n        function calculateIdealCameraDistance() {\n            // Get aspect ratio from configuration\n            const aspect = CONFIG.useFixedDimensions \n                ? CONFIG.gameWidth / CONFIG.gameHeight \n                : CONFIG.gameAspectRatio;\n            \n            // Calculate field of view in radians\n            const fovRadians = camera.fov * (Math.PI / 180);\n            \n            // Calculate distances needed to fit width and height\n            const distanceForWidth = (textWidth / 2) / Math.tan(fovRadians / 2) / aspect;\n            const distanceForHeight = (textHeight / 2) / Math.tan(fovRadians / 2);\n            \n            // Use the larger of the two distances to ensure text fits completely\n            // Add padding factor for safety margin\n            const padding = 1.3; // Increased padding for 4:3 ratio\n            return Math.max(distanceForWidth, distanceForHeight) * padding;\n        }\n        \n        // Animation loop\n        function animate() {\n            requestAnimationFrame(animate);\n            renderer.render(scene, camera);\n        }\n        \n        // Handle window resize\n        function onWindowResize() {\n            if (!CONFIG.useFixedDimensions) {\n                // Update renderer size\n                updateRendererSize();\n                \n                // Adjust camera distance to ensure text remains visible\n                if (textGroup) {\n                    // Calculate new ideal distance\n                    const newDistance = calculateIdealCameraDistance();\n                    \n                    // Update camera position\n                    gsap.to(camera.position, {\n                        z: newDistance,\n                        duration: 0.5,\n                        ease: \"power1.out\"\n                    });\n                }\n            }\n        }\n        \n        window.addEventListener('resize', onWindowResize, false);\n        \n        // Initialize the scene\n        function init() {\n            setupLighting();\n            createInterior();\n            \n            const fontLoader = new FontLoader();\n            fontLoader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', function(font) {\n                const letters = createLetters(font);\n                calculateFinalPositions(letters);\n                \n                // Hide loading message\n                document.getElementById('loading').classList.add('hidden');\n                \n                // Start animations\n                setupCameraAnimation();\n                animateLetters(letters);\n            });\n            \n            animate();\n        }\n        \n        // Listen for animation completion\n        document.addEventListener('animationCompleted', function() {\n            console.log('Animation completed - ready to transition to game');\n            // Here you can add code to transition to the game's main menu\n        });\n        \n        // Start initialization\n        init();\n    </script>\n</body>\n</html>\n",
						"content-type": "html",
						"initially-visible": true,
						"id": "",
						"class": "",
						"allow-context-menu": false,
						"stop-input-events": "no",
						"origin": "top-left",
						"set-color": true,
						"default-color": [
							0,
							0,
							0,
							0
						],
						"set-background-color": false,
						"default-background-color": [
							1,
							1,
							1,
							0
						],
						"auto-font-size": true,
						"allow-text-selection": false,
						"style-attribute": ""
					},
					"uid": 551,
					"sid": 184844235246149,
					"tags": "",
					"instanceVariables": {},
					"behaviors": {},
					"instanceFolderItem": {
						"sid": 184844235246149,
						"expanded": true
					},
					"showing": true,
					"locked": false,
					"world": {
						"x": 2,
						"y": -1,
						"width": 633.3127078600791,
						"height": 474.7367559702314,
						"originX": 0,
						"originY": 0,
						"color": [
							1,
							1,
							1,
							1
						]
					}
				},
				{
					"type": "EventHandler",
					"properties": {
						"initially-visible": true,
						"initial-animation": "Animation 1",
						"initial-frame": 0,
						"enable-collisions": true,
						"live-preview": false
					},
					"uid": 552,
					"sid": 125149034652916,
					"tags": "",
					"instanceVariables": {},
					"behaviors": {},
					"instanceFolderItem": {
						"sid": 125149034652916,
						"expanded": true
					},
					"showing": true,
					"locked": false,
					"world": {
						"x": -27.596145865969206,
						"y": 29.91364367493913,
						"width": 28.89481592787378,
						"height": 28.2118024725087,
						"originX": 0.5,
						"originY": 0.5,
						"color": [
							1,
							1,
							1,
							1
						],
						"angle": 0,
						"zElevation": 0
					}
				}
			],
			"sid": 912084981383230,
			"effectTypes": [],
			"isInitiallyVisible": true,
			"isInitiallyInteractive": true,
			"isHTMLElementsLayer": false,
			"color": [
				1,
				1,
				1,
				1
			],
			"backgroundColor": [
				0.3686274509803922,
				0.3686274509803922,
				0.3686274509803922,
				1
			],
			"isTransparent": false,
			"parallaxX": 0,
			"parallaxY": 0,
			"scaleRate": 1,
			"forceOwnTexture": false,
			"renderingMode": "3d",
			"drawOrder": "z-order",
			"useRenderCells": false,
			"blendMode": "normal",
			"zElevation": 0,
			"global": false
		},
		{
			"name": "Other",
			"overriden": 0,
			"subLayers": [],
			"instances": [],
			"sid": 331559457892221,
			"effectTypes": [],
			"isInitiallyVisible": true,
			"isInitiallyInteractive": true,
			"isHTMLElementsLayer": false,
			"color": [
				1,
				1,
				1,
				1
			],
			"backgroundColor": [
				0.3686274509803922,
				0.3686274509803922,
				0.3686274509803922,
				1
			],
			"isTransparent": true,
			"parallaxX": 1,
			"parallaxY": 1,
			"scaleRate": 1,
			"forceOwnTexture": false,
			"renderingMode": "3d",
			"drawOrder": "z-order",
			"useRenderCells": false,
			"blendMode": "normal",
			"zElevation": 0,
			"global": false
		}
	],
	"scene-graphs-folder-root": {
		"items": [
			{
				"sid": 184844235246149,
				"expanded": true
			},
			{
				"sid": 125149034652916,
				"expanded": true
			}
		],
		"subfolders": []
	},
	"sid": 579449552092982,
	"nonworld-instances": [],
	"effectTypes": [],
	"width": 1280,
	"height": 960,
	"unboundedScrolling": false,
	"vpX": 0.5,
	"vpY": 0.5,
	"projection": "perspective",
	"eventSheet": null
}